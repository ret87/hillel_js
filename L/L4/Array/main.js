'use strict';
console.log('Arrays');

        // Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений и 
        // предлагает дополнительные методы для удобного манипулирования такой коллекцией.
    // Синтаксис для создания нового массива – квадратные скобки со списком элементов внутри. 

    var cars = ['MB', 'BMW', 'Audi'];

    // Обращаясь к имени мы получим все данные об массиве

    console.log(cars);

    // Элементы нумеруются, начиная с нуля.
    // Чтобы получить нужный элемент из массива – указывается его номер в квадратных скобках:

console.log(cars[0]);
console.log(cars[1]);
console.log(cars[2]);

    // Общее число элементов, хранимых в массиве, содержится в его свойстве length:

console.log(cars.length);

    // Элементы можно заменить обратившись к номеру имени массива

cars[2]= 'WW';

    // Или добавить

cars[3]= 'Renault';
console.log(cars);
// alert(cars);

    // В массиве может храниться любое число элементов любого типа.
    // получить объект из массива и тут же -- его свойство

cars[4]={mark:'BMW i3'};
console.log(cars);
console.log(cars[4].mark);

//  //
        // Методы pop/push, shift/unshift - добавляют или удаляют елементы в начало или конец массива
    // pop - Удаляет последний элемент из массива и возвращает его:

cars.pop();
console.log(cars);

    // push - Добавляет элемент в конец массива:

cars.push('BMW i5');

    // arr[arr.length] = ''; так же добавляет в конец массива:

cars[cars.length] = 'BMW i7';
console.log(cars);

    // shift Удаляет из массива первый элемент и возвращает его:

cars.shift();
console.log(cars);

    //unshift Добавляет элемент в начало массива:

cars.unshift('Mazda RX9');
console.log(cars);

    // Методы push и unshift могут добавлять сразу по несколько элементов:

cars.push('BMW i3', 'BMW i8', 'BMW i9');
console.log(cars);
cars.unshift('Mazda RX7', 'Mazda RX8');
console.log(cars);

//    // 
        // Внутреннее устройство массива
    // Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length.
    // Так как это объект, то в функцию он передаётся по ссылке:

function eat(cars) {
    cars.pop();        //задали функции определённое действие - но вызовем функцию чуть позже
}
console.log(cars);
eat(cars);             //вызвали функцию дважды и действие произошло - дважды
eat(cars);             //вызвали функцию дважды и действие произошло - дважды
console.log(cars);

    // Ещё одно следствие – можно присваивать в массив любые свойства.

var cars2 = [];
cars2[53] = 'Audi R8';
console.log(cars2);
    // … Но массивы для того и придуманы в JavaScript, чтобы удобно работать именно с упорядоченными,
    //  нумерованными данными. Для этого в них существуют специальные методы и свойство length.

    // Быстродействие массивов - те что работают с концом массива - быстродейственние, те которые с началом - медленнее.
    // pop/push - быстрее чем  shift/unshift 

//      //
        // Перебор элементов
    // Не стоит использовать for..in
    // Гораздо лучше for (var i=0; i<arr.length...) обращаться к arr[i];

for(var i=0; i < cars.length; i++){
    console.log(cars[i]);
}

//      //
    //Используем length для укорачивания массива, но значения назад уже не вернутся

cars.length =5;
console.log(cars);

//      //
        //Создание вызовом new Array
    //var arr = new Array() - создаёт новый массив с именем от VAR и значениями в скобках или числом - на наш выбор

var cars3 = new Array('Toyota', 'Honda', 'Hunday');
console.log(cars3);
var cars4 = new Array(5);
console.log('new Array(5)' + cars4);

//      //
        // Многомерные массивы
    //это массивы в которых вложены другие массивы 

var matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
] 
console.log(matrix);
console.log(matrix[1]);
console.log(matrix[0][0]);


//      //
        //Внутреннее представление массивов
    //Современные интерпретаторы стараются оптимизировать их и хранить в памяти не в виде хэш-таблицы, 
    // а в виде непрерывной области памяти, по которой легко пробежаться от начала до конца.
    // Чтобы у интерпретатора получались эти оптимизации, программист не должен мешать:
    // -- Не ставить массиву произвольные свойства, такие как arr.test = 5. То есть, работать именно как с массивом, 
    // а не как с объектом.
    // -- Заполнять массив непрерывно и по возрастающей. Как только браузер встречает необычное поведение массива, 
    // например устанавливается значение arr[0], а потом сразу arr[1000], то он начинает работать с ним, как с обычным объектом. 
    // Как правило, это влечёт преобразование его в хэш-таблицу.
    
    // Так не стоит делать!
var arr=[];
arr.test = 5
console.log(arr);

    // Так тоже!
arr.length = 100;
console.log(arr);

    // И вот так тоже!
arr[1]=10;
arr[5]=20;
arr[20]=30;
console.log(arr);


//      //
        // Итого
    // Массивы существуют для работы с упорядоченным набором элементов.

    // Объявление:

    // // предпочтительное
    // var arr = [элемент1, элемент2...];
    
    // Или
    // // new Array
    // var arr = new Array(элемент1, элемент2...);
    // При этом new Array(число) создаёт массив заданной длины, без элементов.

    // Свойство length – длина массива. Если точнее, то последний индекс массива плюс 1. 
    // Если её уменьшить вручную, то массив укоротится. Если length больше реального количества элементов, 
    // то отсутствующие элементы равны undefined.

    // Массив можно использовать как очередь или стек.

    // Операции с концом массива:

    // arr.push(элемент1, элемент2...) добавляет элементы в конец.
    // var elem = arr.pop() удаляет и возвращает последний элемент.
    // Операции с началом массива:

    // arr.unshift(элемент1, элемент2...) добавляет элементы в начало.
    // var elem = arr.shift() удаляет и возвращает первый элемент.
    // Эти операции перенумеровывают все элементы, поэтому работают медленно.