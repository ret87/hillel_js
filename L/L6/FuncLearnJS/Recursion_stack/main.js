'use strict';
console.log('Functions');

    // // Рекурсия, стек
// Рекрусия - функция в функции, например функция вызывающая саму себя.
// Глубина рекрусии - это общее колличество вложенных вызовов. (тут он равен n)
// Базис рекрусии - это  конец вычисления - значение на котором закончились вычисления. (тут он 1)
// Рекрусию используют, когда вычисления функции можно свести к более простому вызову, а его ещё к более простому, 
// и т.д., пока значение не станет очевидным
// Рекрусия может быть переделана в цикл (если условия довольно просты, шаги и подвызовы не сложны)

// пример
function pow(x, n){
    if(n != 1){ 
        // return x **n; 
        return x * pow(x, n-1); 
    } else {
        return x;
    }
}
console.log(pow(2,5));
// функция будет отсчитывать и запоминать все значения X и N, пока N не будет соблюдено условие - до   N=1, 
// как только дойдёт до условия (N=1), начнётся обратное действие но уже с известными значениями и выдаст последнее.
// по сути в этом примере реализован метод перебор с помощью 2ух функций. и выводом последнего значения.

    // // Контекст выполнения, стек
// У каждого вызова функции есть свой контекст выполнения - это этапы запуска функции, которые соотвествуют условиям.
// Интерпретатор сохраняет и запоминает каждое место в коде, переменную и их значения, которые он проходит.
// Все данные удовлетворяющие условия - записываются в стек контекстов.
// После получения всех значений, интерпретатор переходит к следующему этапу функции (если он есть).
// И выдаёт согласно запросу - коду, что требуется (последний, все и тд)

function pow2(x,n){
    var result = x;
    for(var i=1; i<n; i++){
        result *=x;
    }
    return result;
}
console.log(pow(3,4));
// мы создаём ПЕРЕМЕННУЮ и приравниваем её к Х, для того что бы далее эту ПЕРЕМЕННУЮ использовать в цикле;
// после создаём цикл в функции, который будет перебирать числа от наименьшего по условию i= 1, до наибольшего i<n
// каждый шаг цикла будет записывать с в ПЕРЕМЕННУЮ данные Х*Х, а следующий шаг перезаписывать эти данные.


    // // Итого
// Рекурсия – это когда функция вызывает сама себя, как правило, с другими аргументами.
// Также рекурсия используется для работы с «естественно рекурсивными» структурами данных, 
// такими как HTML-документы, для «глубокого» копирования сложных объектов.



    // // Практика
// 1. Задача
// Напишите функцию sumTo(n), которая для данного n вычисляет сумму чисел от 1 до n, например:
// вариант через цикл
function sumTo(n1){
    var resultN = n1;
    for(var i=n1; i>1; i--){
        n1 = i;
        resultN +=n1-1;

    }
    return resultN;
}
console.log(sumTo(100));

// вариант через рекрусию
function sumTo2(n2){
    if(n2 > 1){ 
        return n2 + sumTo2(n2-1); 
    } else {
        return n2;
    }
}
console.log(sumTo2(100));

// Решение по формуле: sumTo(n) = n*(n+1)/2:
function sumTo3(n3){
    if(n3 > 1){ 
        return n3 * (n3+1)/2; 
    } else {
        return n3;
    }
}
console.log(sumTo3(100));


// 2. Задача 
// факториал числа 5:  n * (n-1)!
function factorial(f){
    if(f>1){
        return f*(factorial(f-1));
    } else {
        return f;
    }

}
console.log(factorial(5));


// 3. Задча
// Числа Фибоначчи
// рекруссия
function fib(f2){
    if(f2 > 1){ 
        return f2 = fib(f2-1) + fib(f2-2); 
    } else {
        return f2;
    }
}
console.log(fib(17));
// // алгоритм вычисления в цикле
var a =1, b=1, c, n=17;
for(var i=3;i<=n;i++){
    c = a + b;
    a = b;
    b = c;
}
console.log(c);